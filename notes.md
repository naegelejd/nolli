# Implementation Notes

Nolli is intended to be fully re-entrant to support using the language implementation
(as a library) in IDEs and so on. For this reason, most functions (API or otherwise)
take some type of state `struct` as their first argument.

## Walkthrough

### Lexical Scanning/Tokenizing
Nolli's lexical scanner is very similar to that of the language Lua.
The code is very easy to read and understand as it does not use any lookup tables
to implement a state machine. The `gettok` function reads one `char` at a time
from either an input file or a `char*`, constructing and returning tokens when possible.

### Parsing
Nolli uses a simple, recursive-descent, single token lookahead parser.
The parser constructs an abstract syntax tree (AST) using a family of AST creation
functions. The parser (and lexer) are not type-aware, so type names are parsed as
identifiers themselves.

The parser is capable of recovering from some syntax errors by synchronizing on
semicolons to reach the end of the statement in which an error occurs.

Logic for static vs. interactive parsing:

### Abstract Syntax Tree
The AST nodes are individually allocated on request. AST Nodes are implemented using a union
of all the different types of syntactical constructs. This may be less type-safe in C, but it
it's better than casting the type of every node. It also allows for AST nodes to be easily
allocated using a memory pool which can be freed after semantic analysis.

### Static Type-Checking
The AST generated by the parser is traversed in order to compare each
expression's resulting type with the type of the identifer it
is assigned to. Assignees include local variables, function arguments, struct
members, etc.

Statement blocks are traversed using breadth-first search, while expressions
are traversed using depth-first search.

This phase must account for variable scope. This means each scope has it's own
symbol table that inherits the symbols from its parent scope's symbol table.

For every type error, an error message is generated.

The inferred types of identifiers in short declarations is also determined
in this step.

### Code Generation
The type-checked AST is then traversed to generate... TBD (intermediate represenatation).

## TODO

- [bug] return NULL in every parser function when an error occurs
- [bug] free `struct ast`s when errors occur during parsing
- [bug] fix broken real number parsing (exponent/mantissa/etc...)
- handle error messages in a fashion suitable for a library
- type check
- 'libify' - make sure nolli is always embeddable, re-entrant, linkable
- intermediate representation
- garbage collector
- coroutines
- x86 assembly output

## Complete

- the parser need to respect operator associativity (POW symbol is right-associative)
- the parser needs to respect operator precedence. I plan to use the
  Shunting Yard algorithm to parse expressions.
- the parser needs better error recovery (synch on semicolons, setjmp, etc.)

## Feature Ideas

- shorthand variable initialization (i.e. `name := "joe"`)
- macros/templates
- various backend code generation
    - C code
    - x86 assembly
    - JIT compilation
    - virtual machine bytecode (w/ runtime)
- use pools for allocating AST nodes?
- exceptions

## Builtin functions

id
map
foldl
foldr
filter
zip
zipWith

## Type notes

### Base Types

bool    - boolean
chr     - character
int     - integral number
real    - real number
str     - character list
lst     - homogeneous collection of values
map     - homogeneous collection of key-value pairs
tup     - heterogeneous collection of base type instances
func    - function
strm    - IO stream (reading/writing)

tup and func types are actually defined by their signature, i.e.

1. every possible grouping combination of base types is an individual `tup` type
1. every possible combination of return types and parameter types is an individual `func` type

## Keywords

This list of keywords includes builtin type names. A tool like `gperf` could generate a
perfect hash function for this list, which could then be used in a parser.

bool
char
int
real
str
list
map
file
func
struct
iface
module
import
from
alias
return
break
continue
if
else
for
in
while
true
false

## Implementation Ideas

### Grammar

weird idea example:

    Square is defined by:
        width of type int,
        height of type int.

    Shape has:
        area of type int,
        scale(int x).

    Square is a shape.

    Square's int area: return width * height
    Square's scale(int x): ...
    Square's private(): do_something()

